BFS（广度优先遍历）：层序遍历

​	BFS遍历使用队列数据结构。

```java
void bfs(TreeNode root){
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    while(!q.isEmpty()){
        TreeNode tmp = q.poll();
        if(tmp.left!=null){
            q.add(tmp.left);
        }
        if(tmp.right!=null){
            q.add(tmp.right);
        }
    }
}
```

[leetcode 102 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

​	这里使用层序遍历，用队列来记录每一层进队出队，每一层的遍历开始前，先记录队列中的节点数量n，然后一次处理完这一层的n个节点

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> q = new LinkedList<>();
    if(root == null){	//如果根节点为空，直接返回
        return res;	
    }
    q.add(root);
    while(!q.isEmpty()){
        List<Integer> level = new ArrayList<>();	//用于保存当前层的节点值
        int n = q.size();
        for(int i = 0; i < n; i++){	//一次处理完当前层的所有节点
            TreeNode tmp = q.poll();
            level.add(tmp.val);
            if(tmp.left!=null){
                q.add(tmp.left);
            }
            if(tmp.right!=null){
                q.add(tmp.right);
            }
        }
        res.add(level);	//把当前层所有节点存到结果数组
    }
    return res;
}
```

[leetcode 103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

​	层序遍历的思路上，使用双端队列Level，在遍历每一层的时候，加入一个标记来进行标记进行翻转插入到Level

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
	List<List<Integer>> res = new ArrayList<>();
    Queue<TreeNode> q = new LinkedList<>();
    if(root == null){
        return res;
    }
    q.add(root);
    boolean flag = true;	//标志顺序，从左到右，还是从右到左
    while(!q.isEmpty()){
        int n = q.size();
        LinkedList<Integer> level = new LinkedList<>();
        for(int i = 0; i < n; i++){
            TreeNode tmp = q.poll();
            if(flag){	//从右到左
                level.addLast(tmp.val);
            }else{
                level.addFirst(tmp.val);
            }
            if(tmp.left!=null){
                q.add(tmp.left);
            }
            if(tmp.right!=null){
                q.add(tmp.right);
            }
        }
        res.add(new ArrayList(level));
        flag = !flag;
    }
    return res;
}
```

[leetcode 105. 前序中序遍历序列构建二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

​	前序遍历：{根节点}{左子树}{右子树}

​	中序遍历：{左子树}{根节点}{右子树}

​	所以可以通过递归方式，每次从前序遍历序列找到根节点root，将root在中序遍历序列的位置找到，那么左边都是左子树，右边都是右子树，然后前序遍历的指针向右移动左子树的长度，找到下一个根节点，如此反复。在中序遍历找root的所在位置，可以先用hashMap存储所有节点的索引，便于查找

```java
public TreeNode buildTree(int[] preorder, int[] inorder){
    HashMap<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < inorder.length; i++){
        map.put(inorder[i], i);
    }
    return buildTreeHelp(preorder, 0, preorder.length, inorder, 0, inorder.length, map);
}

private TreeNode buildTreeHelp(int[] preorder, int p_start, int p_end, int[] inorder, int i_start, int i_end, HashMap<Integer, Integer> map){
    //终止条件：前序序列为空
    if(p_start == p_end){
        return null;
    }
    int root_val = preorder[p_start];
    TreeNode root = new TreeNode(root_val);
    int i_root_index = map.get(root_val);
    int leftNum = i_root_index - i_start;
    root.left = buildTreeHelp(preorder, p_start+1, p_start + leftNum + 1, inorder, i_start, i_root_index, map);
    root.right = buildTreeHelp(preorder, p_start + leftNum + 1, p_end, inorder, i_root_index + 1, i_end, map);
    return root;
}
```

[leetcode 124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

​	定义一个maxGain(node)计算一个节点的最大贡献值

```java
int ans = 0;
public int maxPathSum(TreeNode root){
    maxGain(root);
    return res;
}
private int maxGain(TreeNode root){	//获取当前节点的最大贡献值
    if(root == null){
        return 0;
    }
    int left = Math.max(0, maxGain(root.left));	//左子树最大贡献值
    int right = Math.max(0, maxGain(root.right));	//右子树最大贡献值
    ans = Math.max(ans, left+right+root.val);	//将结果存储
    return root.val+Math.max(maxGain(root.left), maxGain(root.right));	//找最大的子节点走下去
}
```

[leetcode 199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

​	在层序遍历的基础上，获取每一层的最右侧的节点，就当每一层遍历到最右侧节点时，将该节点添加到结果集中

```java
public List<Integer> rightSideView(TreeNode root){
    List<Integer> res = new ArrayList<>();
    Queue<TreeNode> q = new LinkedList<>();
    if(root == null){
        return res;
    }
    q.add(root);
    while(!q.isEmpty()){
        int n = q.size();
        for(int i = 0; i < n; i++){
            TreeNode tmp = q.poll();
            if(tmp.left!=null){
                q.add(tmp.left);
            }
            if(tmp.right!=null){
                q.add(tmp.right);
            }
            if(i == n-1){	//到了每一层的最右侧，将节点添加
                res.add(tmp.val);
            }
        }
    }
    return res;
}
```

[leetcode 144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

​	前序遍历：先遍历根节点，再遍历左子树，再遍历右子树

​	递归做法：

```java
List<Integer> res = new ArrayList<>();
public List<Integer> preorderTraversal(TreeNode root){
    preorder(root);
    return res;
}
private void preorder(TreeNode root){
    if(root == null) return;
    res.add(root.val);
    if(root.left!=null){
        preorder(root.left);
    }
    if(root.right!=null){
        preorder(root.right);
    }
}
```

​	迭代做法：使用一个栈来存储节点，首先将节点和节点的左子树全部压入栈中，然后遍历弹出节点的右子树

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    preorder(root, res);
    return res;
}
private void preorder(TreeNode root, List<Integer> res){
    Stack<TreeNode> stack = new Stack<>();	//存储节点
    while(root!=null||!stack.isEmpty()){	//当前节点不为空，且栈不为空
        while(root!=null){
            res.add(root.val);	//先存储根节点的值
            stack.add(root.left);	//将左子树压入栈
            root = root.left;	//遍历下一个左子树节点
        }
        root = stack.pop().right;	//遍历下一个右子树
    }
}
```

[leetcode 104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

​	递归：一个二叉树的深度就是两个子树的深度取最大值加1

```java
public int maxDepth(TreeNode root){
    //终止条件
    if(root == null)	return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

[leetcode 236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

​	递归寻找，我们需要的结果就是当前节点是否存在我们要找的p和q节点。分为以下几种情况讨论：

​		1、当前root节点为p节点或者q节点，那么直接返回root，因为最近的公共祖先就是root

​		2、如果当前节点的左子树或者右子树都不为空，则说明p节点和q节点在root节点两侧

​		3、如果当前节点左子树为空或者右子树为空，返回不为空的那个子树节点，其中一个为空，说明在p和q在同侧，继续返回不为空的节点，继续递归就是了

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){
    if(root == null) return null;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if((left!=null && right!=null)||(root == p || root == q)){
        return root;
    }
    if(left == null){
        return right;
    }
    if(right == null){
        return left;
    }
    return null;
}
```

[leetcode 226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

​	使用递归函数，将左子树所有节点存储到left中，将右子树所有节点存储到right中，将root的左子树和右子树进行交换，终止条件是，root为空

```java
public TreeNode invertTree(TreeNode root){
    if(root == null) return null;
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
}
```

[leetcode 101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

​	递归函数：判断树的左右子树是否一样。1、如果root为空，说明是对称二叉树；2、root的左子树或者root右子树其中一个为空，那么这个树就不是对称的；3、当前左右节点的值相同，就得判断左节点的左孩子和右节点的右孩子，左节点的右孩子和右节点的左孩子是否相等

```java
public boolean isSymmetric(TreeNode root){
    return isMirror(root, root);
}
private boolean isMirror(TreeNode p, TreeNode q){
    if(p == null && q == null) return true;	//情况1
    if(p == null || q == null) return false;	//情况2
    if(p.val == q.val){	//情况3
        return isMirror(p.left, q.right) && isMirror(p.right, q.left);
    }
    return false;
}
```

[leetcode 96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

​	递归：[1...i]全部为i的左子树，[i...n]全部为i的右子树，当i为0或者为1的时候，数量只有一个，而总数为左子树数量乘以右子树数量

```java
public int numTrees(int n){
    if(n == 0 || n == 1) return 1;
    int ans = 0;
    for(int i = 1; i <= n; i++){
        ans += numTrees(i - 1) * numTrees(n - i);
    }
    return ans;
}
```

​	备忘录递归：用数组来保存每次加的结果，下次调用的时候，可以直接通过数组来取保存的结果

```java
int[] mem;
public int numTrees(int n){
    if(n == 0 || n == 1) return 1;
    mem = new int[n+1];
    mem[0] = mem[1] = 1;
    return recur(n);
}
private int recur(int n){
    if(mem[n] != 0) return mem[n];
    int res = 0;
    for(int i = 1; i <= n; i++){
        res += recur(i-1) * recur(n - i);
    }
    mem[n] = res;
    return res;
}
```

[leetcode 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

​	